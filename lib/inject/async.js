// Generated by CoffeeScript 1.4.0
var Defer, argsOf, sequence;

argsOf = require('../util').argsOf;

Defer = require('when').defer;

sequence = require('when/sequence');

module.exports = function(Preparator, decoratedFn) {
  var seq, _id;
  seq = 0;
  _id = seq;
  if (typeof Preparator !== 'object' || Preparator instanceof Array) {
    throw new Error('also.inject.async(Preparator, decoratedFn) requires Preparator as object');
  }
  if (Preparator.parallel == null) {
    Preparator.parallel = true;
  }
  return (function(context, beforeAllDone) {
    var beforeAll, calls, queue, queueLength;
    context.signature = argsOf(decoratedFn);
    queue = [];
    calls = [];
    queueLength = function() {
      var item, length, _i, _len;
      length = 0;
      for (_i = 0, _len = queue.length; _i < _len; _i++) {
        item = queue[_i];
        if (!item.done) {
          length++;
        }
      }
      return length;
    };
    beforeAll = function() {
      var defer, done;
      defer = Defer();
      if (beforeAllDone) {
        return defer.resolve();
      }
      if (!((Preparator.beforeAll != null) && typeof Preparator.beforeAll === 'function')) {
        return defer.resolve();
      }
      beforeAllDone = true;
      done = function(result) {
        if (result instanceof Error) {
          return defer.reject(result);
        }
        return defer.resolve(result);
      };
      Preparator.beforeAll(done, context);
      return defer.promise;
    };
    Object.defineProperty(context, 'args', {
      enumerable: true,
      get: function() {
        return queue[_id].args;
      }
    });
    Object.defineProperty(context, 'defer', {
      enumerable: true,
      get: function() {
        queue[_id].altDefer = true;
        return queue[_id].defer;
      }
    });
    Object.defineProperty(context, 'first', {
      enumerable: true,
      get: function() {
        return queue[_id].first;
      }
    });
    Object.defineProperty(context, 'last', {
      enumerable: true,
      get: function() {
        return queue[_id].last;
      }
    });
    Object.defineProperty(context, 'queue', {
      enumerable: true,
      get: function() {
        return {
          length: queueLength()
        };
      }
    });
    calls.push(function() {
      var afterEach, arg, args, beforeEach, callDecoratedFn, finished, id, _i, _len;
      id = seq++;
      args = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        args.push(arg);
      }
      queue[id] = {
        done: false,
        defer: Defer(),
        altDefer: false,
        first: [],
        last: [],
        args: args
      };
      finished = Defer();
      beforeEach = function() {
        var defer, done;
        defer = Defer();
        if (!((Preparator.beforeEach != null) && typeof Preparator.beforeEach === 'function')) {
          return defer.resolve();
        }
        done = function(result) {
          _id = id;
          finished.notify({
            beforeEach: result
          });
          if (result instanceof Error) {
            return defer.reject(result);
          }
          return defer.resolve(result);
        };
        _id = id;
        Preparator.beforeEach(done, context);
        return defer.promise;
      };
      callDecoratedFn = function() {
        _id = id;
        if (queue[id].altDefer) {
          decoratedFn.apply(null, queue[id].first.concat(args).concat(queue[id].last));
        } else {
          decoratedFn.apply(null, [
            function(result) {
              finished.notify({
                result: result
              });
              if (result instanceof Error) {
                return queue[id].defer.reject(result);
              }
              return queue[id].defer.resolve(result);
            }
          ].concat(queue[id].first.concat(args).concat(queue[id].last)));
        }
        return queue[id].defer.promise;
      };
      afterEach = function() {
        var defer, done;
        defer = Defer();
        if (!((Preparator.afterEach != null) && typeof Preparator.afterEach === 'function')) {
          return defer.resolve();
        }
        done = function(result) {
          _id = id;
          queue[id].done = true;
          finished.notify({
            afterEach: result
          });
          if (result instanceof Error) {
            return defer.reject(result);
          }
          return defer.resolve(result);
        };
        _id = id;
        Preparator.afterEach(done, context);
        return defer.promise;
      };
      sequence([beforeAll, beforeEach, callDecoratedFn, afterEach]).then(function(results) {
        return finished.resolve(results[2]);
      }, function(error) {
        if (Preparator.error instanceof Function) {
          Preparator.error(error);
        }
        return done.reject(error);
      }, finished.notify);
      return finished.promise;
    });
    return calls.shift();
  })(function() {}, false);
};
